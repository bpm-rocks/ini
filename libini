#!/usr/bin/env bash

. bpm
bpm::include array
bpm::include assign
bpm::include string
bpm::include is


# Retrieves a list of sections, list of keys, or a key's value.
#
# $1 - Target variable.
# $2 - Prefix, required.
# $3 - Section, optional. Required if you want to access a key.
# $4 - Key name, optional
#
# Examples
#
#   # Assume the following INI file:
#   #
#   # [sectionName]
#   # keyName = theValue
#
#   ini::parse INI "$iniFileContents"
#   ini::get target INI
#   set | grep ^target=
#   # target=([0]="" [1]="sectionName")
#
#   ini::get target INI sectionName
#   set | grep ^target=
#   # target=([0]="keyName")
#
#   ini::get target INI sectionName keyName
#   # target="theValue"
#
# Returns nothing
ini::get() {
    local keyName target value

    target=${1-}
    shift

    # shellcheck disable=SC2068
    ini::keyName keyName "$@"

    if [[ "$#" -lt 3 ]]; then
        if [[ -z "${!keyName+_}" ]]; then
            value=()
        else
            # shellcheck disable=SC1087
            eval "value=( \${$keyName[@]+\"\${$keyName[@]}\"} )"
        fi

        # shellcheck disable=SC2068
        local "$target" && assign::array "$target" ${value[@]+"${value[@]}"}
    elif ! is::set "$keyName"; then
        local "$target" && assign::value "$target" ""
    else
        local "$target" && assign::byRef "$target" "$keyName"
    fi
}


# Encode a prefix, section and key in order to generate a safe variable name
# for Bash. All section names and key names are case insensitive.
#
# $1 - Prefix for environment variables, required.
# $2 - Section, optional. Required if you want to access a key.
# $3 - Key name, optional.
ini::keyName() {
    local name part target

    target="$1"
    shift
    name="$1"

    if [[ $# -gt 1 ]]; then
        string::toUpper part "$2"
        string::toHex part "$part"
        name+="_$part"

        if [[ $# -gt 2 ]]; then
            string::toUpper part "$3"
            string::toHex part "$part"
            name+="_$part"
        fi
    fi

    local "$target" && assign::value "$target" "$name"
}


# Parses an INI file into the environment.
#
# $1 - Prefix for environment variables that will be assigned.
# $2 - INI file contents
#
# Variables are stored in memory, encoded in hex to ensure the variable names
# are valid variables.
#
#   PREFIX=(array of unencoded section names)
#   PREFIX_SECTIONENCODED=(array of unencoded key names)
#   PREFIX_SECTIONENCODED_KEYENCODED=value
#
# Duplicted section names are merged together. Duplicated keys will have their
# values changed into an array so all of the values will be captured. For
# example, the INI on the left will be parsed into variables similar to the
# right side. Keep in mind that section names and keys are case insensitive.
#
# [Section1]       PREFIX=(SECTION1 SECTION2
# Key=value
# kEy=value2       PREFIX_SECTION1=(KEY)
#
# [Section2]       PREFIX_SECTION2=(ANOTHER)
# another=value
#                  PREFIX_SECTION1_KEY=(value value2 value3)
# [SECTION1]
# KEY=value3       PREFIX_SECTION2_ANOTHER=value
#
# You should not use the generated environment variables directly. Instead, use
# the other utility functions (eg. `ini::get`) to access the values.
#
#     $1: Prefix for variables.
#     $2: INI file contents
ini::parse() {
    local encodedKey encodedSection key keys IFS line prefix previousValue section sections upper value

    prefix=$1
    sections=("")
    section=
    keys=()
    IFS=$'\n'
    ini::keyName encodedSection "$prefix" "$section"

    while read line; do
        string::trim line "$line"

        #: Eliminate comments starting with # or ;
        line=${line#\#*}
        line=${line#;*}

        if [[ "${line:0:1}" == '[' ]] && [[ "${line:${#line}-1}" == "]" ]]; then
            #: Remove brackets
            line=${line:1:${#line}-2}

            # Save the previously loaded section
            # shellcheck disable=SC2068
            assign::array "$encodedSection" ${keys[@]+"${keys[@]}"}

            string::trim section "$line"
            ini::keyName encodedSection "$prefix" "$section"
            string::toUpper upper "$section"

            # shellcheck disable=SC2068
            if ! array::contains "$upper" ${sections[@]+"${sections[@]}"}; then
                # Track the new section
                sections[${#sections[@]}]=$upper
                keys=()
            else
                # Load the repeated section. Sorry for the eval.
                # shellcheck disable=SC1087
                eval "keys=( \${$encodedSection[@]+\"\${$encodedSection[@]}\"} )"
            fi
        elif [[ -n "$line" ]]; then
            IFS="=" read key value <<< "$line"
            string::trim key "$key"

            if [[ -n "$key" ]]; then
                string::trim value "$value"
                ini::keyName encodedKey "$prefix" "$section" "$key"

                if ! is::set "$encodedKey"; then
                    assign::value "$encodedKey" "$value"
                elif ! is::array "$encodedKey"; then
                    assign::value previousValue "${!encodedKey}"
                    assign::array "$encodedKey" "$previousValue" "$value"
                else
                    assign::byRef previousValue "$encodedKey"
                    assign::array "$encodedKey" "${previousValue[@]}" "$value"
                fi

                string::toUpper upper "$key"

                # shellcheck disable=SC2068
                if ! array::contains "$upper" ${keys[@]+"${keys[@]}"}; then
                    keys[${#keys[@]}]=$upper
                fi
            fi
        fi
    done <<< "$2"

    # shellcheck disable=SC2068
    assign::array "$encodedSection" ${keys[@]+"${keys[@]}"}

    # shellcheck disable=SC2068
    assign::array "$prefix" ${sections[@]+"${sections[@]}"}
}


# Generates a unique INI file prefix that has not yet been used.
#
# $1 - Destination variable name for the INI prefix.
#
# Returns nothing.
ini::prefix() {
    local prefix

    #: 1 in 32k
    prefix="ini_${RANDOM}"

    while is::set "$prefix"; do
        #: 1 in 1 billion
        prefix="ini_${RANDOM}_${RANDOM}"
    done

    local "$1" && assign::value "$1" "$prefix"
}


# Transfers the in-memory contents of the INI file back into a string.
#
# You will lose all of your comments that were in the INI file. The order of
# the sections may not be preserved. The order of the keys may not be
# preserved. Any values that were overwritten in the original INI file
# shall be eliminated.
#
# Think of it as a cleansing to see what's really parsed instead of losing
# data.
#
# $1 - Destination variable name for the string.
# $2 - INI prefix
#
# Returns nothing.
ini::toString() {
    local key keys nl prefix result section sections value values

    prefix=$2
    nl=$'\n'
    ini::get sections "$prefix"
    for section in "${sections[@]}"; do
        keys=()
        ini::get keys "$prefix" "$section"

        if [[ "${#keys[@]}" -gt 0 ]]; then
            result="$result[$section]$nl"

            for key in "${keys[@]}"; do
                values=()
                ini::get values "$prefix" "$section" "$key"

                if is::array values; then
                    for value in "${values[@]}"; do
                        result="$result$key=$value$nl"
                    done
                else
                    result="$result$key=$values$nl"
                fi
            done

            result="$result$nl"
        fi
    done

    local "$1" && assign::value "$1" "$result"
}
